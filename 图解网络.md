# TCP/IP网络模型有几层
- 应用层
- 传输层 TCP
- 网络层 IP
- 网络接口层 Frame
# 键入网址到页面显示，其中发生了什么
1. HTTP解析URL
2. DNS解析域名，得到目标IP地址
3. TCP三次握手，打包HTTP生成TCP包
4. IP封装TCP形成网络包
5. MAC封装形成MAC包
6. 网卡发送MAC包
# Linux系统是如何收发网络包的
### 接受软件包

- 网卡将网络包写入指定内存，既Ring Buffer环形缓冲区
- NAPI机制通知OS轮询数据，ksoftirqd线程获取数据帧交给协议层处理
- 协议层判断合法性和协议类型，去掉帧头帧尾交给网络层
- 网络层取出IP包，判断TCP/UDP，去掉IP头交给传输层
- 传输层取出TCP/UDP头，根据四元组交给Socket放进Socket缓冲区
- 用户调用Socket接口，拷贝Socker缓冲区数据进应用层数据，唤醒用户进程
### 发送软件包

- 内存申请sk_buff，将用户待发送数据写入sk_buff，加入发送缓冲区（使用TCP协议时将会拷贝一个新的sk_buff，等收到对方ACK之后再删除）
- 对sk_buff填充TCP头交给网络层
- 网络层选取路由、填充IP、分包，交给接口层
- 接口层ARP协议获得MAC，填充头尾，放进发送队列
- # HTTP状态码
「200 OK」是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。
「204 No Content」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。
「206 Partial Content」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。
3xx 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。
「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。
「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。
「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。
4xx 类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。
「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。
「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。
5xx 类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。
「500 Internal Server Error」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。
「501 Not Implemented」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。
「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
「503 Service Unavailable」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。
# GET和POST
GET是从服务器获取指定资源，参数写在URL里，只能请求ASCII字符，且对长度有限制。**GET是安全且幂等的，可以对GET请求的数据作缓存，也可以做到代理上（nginx），浏览器也可以保存GET请求为书签**
POST是根据请求负荷（报文body）对指定资源作处理，数据格式任意，大小无限制。**POST不是安全且幂等的，因为POST要修改服务器上的数据且多次提交创建资源，浏览器一般不会缓存POST**
# HTTP强制缓存与协商缓存
**强制缓存**指浏览器判断本地缓存是否过期，再主动选择是否使用缓存。通过HTTP头部Cache-Control（相对时间）/Expires（绝对时间）和本地请求设置的时间，计算资源是否过期，是否请求服务器
**协商缓存**是与服务端协商判断是否使用本地缓存。通过请求头部中的 If-Modified-Since 字段与响应头部中的 Last-Modified 字段实现或请求头部中的 If-None-Match 字段与响应头部中的 ETag 字段
**协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求**
# HTTP/1.1优缺点
**优点**：简单并易于理解；灵活易于扩充；应用广泛，可跨平台
**缺点**：无状态，需要用cookie等技术解决；明文传输，信息裸奔，不安全，容易被监听泄露，无法证明报文完整性，**可通过HTTPS方式解决（引入SSL/TLS层）**
# HTTP/1.1性能
**长连接**，减少TCP重复链接断开的开销，降低服务器负载
**管道网络传输Pipeline**，减少整体响应时间（但是浏览器基本都不支持），但是服务器必须按照请求顺序发送处理请求的相应，**所以HTTP/1.1管道解决了请求队头阻塞，但是没有解决响应队头阻塞**
# HTTPS和HTTP区别
HTTPS在TCP和HTTP网络层间加入了SSL/TLS安全协议，使报文加密传输，解决HTTP明文传输存在安全风险的问题
HTTPS在三次握手后再进行SSL/TLS握手，才可进入加密报文传输
HTTP端口号80，HTTPS端口号443
HTTPS需要申请数字证书，保证服务器身份可信
# HTTPS如何解决HTTP安全问题
**混合加密**实现信息的机密性（对称加密和非对称加密）
**摘要算法**实现了完整性（摘要算法算出哈希值指纹，公司钥加密解密内容）
将服务器公钥加入**数字证**书中，解决了冒充的风险（数字证书包含公钥）
# HTTPS如何建立连接
SSL/TLS协议流程
1. 客户端向服务器索要并验证服务器公钥
2. 协商产生会话密钥
3. 采用会话密钥进行加密通信
# HTTPS应用数据如何保证完整性
**TLS记录协议**，保证应用数据的完整性和来源，对HTTP数据加密用记录协议
TLS记录协议将消息分割多个片段并压缩，给片段加上消息认证码（MAC值，通过哈希算法生成），为了保证完整性并进行数据验证，然后压缩片段加上认证码通过对称密码加密，加入数据类型等信息组成的包头成为最终报文数据。
# HTTPS一定是安全可靠的吗
HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全。**可以通过HTTPS双向验证解决这种问题**
# HTTP/1.1，2，3的演变

### HTTP/1.1比1.0提高了什么性能
**长连接**改善了1.0短链接造成的性能开销；**pipeline网络传输**减少整体相应时间
但是仍存在性能瓶颈，**请求/响应头部Header未经压缩**就发送造成延迟，首部信息越大延迟越长；**首部冗长**，互相发送相同首部浪费大；服务器按请求的顺序相应，服务器相应慢会造成**队头堵塞**；**没有优先级控制**；请求只能从客户端开始**，服务器被动响应**
### HTTP/2做了什么优化
- 头部压缩：多个相同请求，压缩头部消除重复部分
- 二进制格式：头信息帧和数据帧，增加传输效率
- 并发传输：多个Stream复用一个TCP链接
- 服务器推送：服务器可以主动发起推送
### HTTP/2有什么缺陷
由于TCP字节流协议的特性，存在队头阻塞问题。即前一个字节数据没到达，后收到的数据只能存在内核缓冲区里，等前一个到达后应用层才能从内核里拿数据。
### HTTP/3作了什么优化
将HTTP下层的**TCP协议换成了UDP**。
### 基于UDP的QUIC协议
- 无队头阻塞：只阻塞丢包的流，不影响其他的流
- 更快的连接建立：QUIC包含TLS/1.3，一个RTT就可建立链接
- 链接迁移：用链接ID标记通信端点，消除重连成本，实现链接迁移
# HTTP/1.1如何优化
### 尽量避免发送HTTP请求
缓存，将**请求-响应**存在本地。如何保证本地缓存是最新的？服务器发送内容时估算过期时间，放在响应头部，客户端接收到后判断是否重发请求。使用Etag头部带上的摘要判断资源是否更新，是否更新缓存。
### 减少HTTP请求次数
- 减少重定向次数：由代理服务器作重定向工作
- 合并请求：一般服务器同时发送5-6个不同TCP请求避免请求阻塞，合并请求减少TCP连接数量。将小资源合并成大资源请求
- 延迟发送请求：按需获取
### 减小HTTP响应数据大小
无损（文本文件等）、有损（图片、视频）压缩资源
# HTTPS RSA握手解析
### TLS四次握手过程
1. 客户端发出ClientHello加密通讯请求，包含客户端信息（TLS协议版本，客户端随机数-用于生成会话密钥，客户端支持的密码套件如RSA）
2. 服务器接受请求，确认TLS版本号和选择密码套件，生成随机数并发出ServerHello（对ClientHello回应）
3. 客户端生成新随机数，用证书的RSA公钥加密该随机数，返回服务器三个随机数，将之前数据摘要加密发送给服务器，验证加密是否可用
4. 服务器收到第三个随机数pre-masterkey计算会话密钥并验证，进入加密通
### RSA缺陷
不支持前向保密。服务器的私钥被破解后，被第三方截获的所有TLS通信密钥都会被破解，可用ECDHE密钥协商算法解决
### HTTPS ECDHE握手解析
ECDHE对称加密算法，基于DHE算法。
**TLS第一次握手**：
客户端发送的ClientHello有生成的随机数
**TLS第二次握手：**
服务器返回ServerHello同样有生成的随机数，但使用非RSA密码套件。同时服务器为了证明身份，会发送Certificate消息，然后把证书也发给客户端。因为使用了ECDHE所以会在发送完证书后发送Server Key Exchange（其中通过椭圆函数计算出私钥和发送给客户端的公钥）。最后发送Server Hello Done
**_TLS两次握手明文共享了Client Random、Server Random、使用的椭圆曲线、椭圆曲线几点G、服务器椭圆曲线的公钥_**
**TLS三次握手：**
客户端验证证书，然后生成随机数作为客户端椭圆曲线私钥，然后根据服务器给的信息生成客户端椭圆曲线公钥，用Client Key Exchange发送给服务器
**_最终的会话密钥通过Client Random+Server Random+ECDHE算出的共享密钥三个材料生成_**
算好会话密钥后发送Change Cipher Spec通知客户端启用对称加密算法通信，然后发送Encrypted Handshake Message，加密已发送数据摘要给服务器进行验证
**TLS四次握手：**
服务器同样操作，发送Change Cipher Spec和Encrypted Handshake Message，客户端验证后双方启用加密通话
### RSA和ECDHE的区别：
- RSA不支持向前加密，ECDHE支持
- RSA需要TLS四次握手才能发消息，ECDHE第三次握手就可以发送加密的HTTP消息
- ECHDE在第二次握手中发送[Server Key Exchange]
# HTTPS如何优化
HTTPS由于加密原因花费至多两个RTT，造成额外性能开销
- **硬件优化：**HTTPS是计算密集型，加CPU/选择支持**AES-NI**特性的CPU
- **软件优化：**软件升级
- **协议优化：**将RSA换成ECDHE减少消息往返RTT，同时增加安全性；对安全性要求不要可以使用AES128GCM，密钥长度较短；TLS升级，1.3相比1.2完成握手只需要一个RTT，**1.3只支持ECDHE**
- **证书优化：证书传输优化**：选择ECDHE，同安全强度下相比RSA密钥长度减少；**证书验证优化**：OCSP，向CA发送请求，CA返回证书有效状态，OCSP Stapling定期向CA查询证书状态，缓存响应结果
- **会话复用：**建立TLS会话后用户SessionID标示密钥（K-V），只用一个往返就可以建立安全通信，但是会造成服务器内存压力变大，网站的负载均衡还会导致连不上同一个服务器；SessionTIcket客户端缓存，类似HTTP的Cookie；SessionID和Ticket**都不具备向前安全性**，需要设置合理过期时间避免重向攻击；TLS1.3使用Pre-shared Key实现0RTT重连
# **HTTP/3**
HTTP/2存在队头阻塞；TCP/TLS握手延迟；网络迁移需要重新链接等问题。
### **QUIC协议的特点：**
将TCP换成UDP，基于UDP在应用层实现了QUIC协议；**无队头阻塞**，UDP乱序发送，无需像TCP数据传输需要顺序，但是可以保证数据的完整性，Stream独立相互之间无影响；**更快链接建立**，TLS1.3只需要一个RTT就可以建立链接，第二次连接时数据包和QUIC握手信息一起发送，0RTT就可以建立链接；**连接迁移**，使用链接ID标记两个端点，IP地址变化但只要上下文信息存在，就可以无缝复用链接。
### **HTTP/3协议特点**
HTTP/3直接使用了QUIC中的Stream，简化了帧结构，将头部压缩算法升级成为了**QPACK**，解决了HPACK动态表需要时序性的问题，使用两个单向流同步双方动态表
# **HTTP和RPC**
HTTP超文本传输协议，RPC远程调用过程；HTTP适用B/S，RPC适用C/S；服务发现过程，HTTP使用DNS，RPC有专门中间服务（Consul Etcd等，也有基于DNS）；都保持TCP底层长链接支持复用，RPC还建立了连接池，提升性能；HTTP（/1.1）使用JSON序列化内容冗余，RPC可以自定义协议提升性能
# **HTTP和WebSocket**
如何保证用户不做操作，网页能收到消息并变更：轮询->长轮询->WebSocket
如何建立WebSocket：客户端在请求里加上特殊Header头（Upgrade：WebSocket）和随机生成Base64码，服务器和客户端生成/验证字符串
**WebSocket生成后就与HTTP没关系了**
WebSocket消息格式：opcode标识类型+payload data（先读前7bit，再决定读不读后面16bit以及64bit）
使用场景：全双工，适用于服务器和客户端需要频繁交互
# **TCP三次/四次握手**

### **TCP头格式：**
序列号：解决网络包乱序问题
确认应答号：解决丢包问题
控制位：ACK确认应答有效、RST出现异常强制断开连接、SYN希望建立链接、FIN不再发送数据希望链接断开连接

### **什么是TCP：**
工作在**传输层**的可靠数据传输服务，确保网络包**无损坏、无间隔、非冗余和按序的。TCP是面向连接的（一对一）、可靠的（保证报文抵达接收端）、基于字节流的**传输层通信协议。
### 什么是TCP链接：
Socket（IP+端口）+序列号+窗口大小

### **如何唯一确定TCP链接：
TCP四元组：源地址、源端口、目标地址、目标端口
最大TCP连接数 = 客户端IP数 * 客户端端口数
服务器最大并发TCP受**文件描述符限制（系统/用户/进程）和内存限制**
### **TCP和UDP区别和应用场景：**
- 连接：TCP面向链接，传输前需要建立链接；UDP不需要链接即刻传输
- 服务对象：TCP一对一；UDP可以一对多、多对多
- 可靠性：TCP可靠交付，无差错不丢失不重复按序到达；UDP尽最大努力交付，不保证可靠，但可以基于UDP建立可靠传输（QUIC）
- 阻塞控制、流量控制：TCP有控制机制；UDP没有，堵塞不影响发送速率
- 首部开销：TCP较长，没有选项为20字节，有则更多；UDP只有8且固定不变
- 传输方式：TCP流式传输无边界，但保证顺序和可靠；UDP一个包一个包发送，但有可能丢包和乱序
- 分片：TCP数据大小基于MSS在传输层分片和组装，以及发送丢失的包；UDP基于MTU，在IP层分片/组装，再传给传输层
- 应用场景：TCP常用于FTP文件传输和HTTP/HTTPS；UDP用于DNS、多媒体、广播等
### **为什么UDP头部没有首部长度而TCP有**
TCP有可变长的**选项**字段，UDP头部长度不变，无需多一个字段记录UDP首部长度
### **为什么UDP首部有包长度而TCP没有**
TCP数据长度 = IP总长 - IP首部长 - TCP首部长
通过IP和TCP首部可知TCP数据长
UDP说法：首部长需要是4的倍数/UDP基于IP协议发展，当初可能不是
### **TCP和UDP可以共用一个端口吗**
**可以**
传输层中的端口号是用于区别一个主机上不同应用程序之间的数据包，而TCP和UDP在内核中是两个完全独立的软件模块
### **TCP三次握手的过程**
1. 客户端、服务器都处于Close状态。服务器主动监听某个端口，处于LISTEN状态
2. 客户端随机初始化序号client_isn，置于TCP首部序号字段，将SYN标志位设置为1，发送报文给服务器，处于SYN-SENT状态
3. 服务器收到SYN，随机初始化序号server_isn，置于TCP首部序号字段，再把TCP首部确认应答号填入client_isn+1，将SYN和ACK标志位设置为1，将该报文发给客户端，服务器处于SYN-RCVD状态
4. 客户端收到报文后，向服务器回应最后一个应答报文，先将该报文头部TCP首部ACK标志为1，再将确认应答号填入server_isn+1，最后发送给服务端，这次报文可以携带数据，客户端进入ESTABLISHED状态
5. 服务端收到报文后，也进入ESTABLISHED状态
### **为什么是三次握手，不是两次、四次**
- 三次握手可以阻止重复历史连接的初始化：如果是两次握手，就无法阻止历史连接，服务器没有中间态给客户端阻止历史连接，导致服务端课能建立一个历史连接，造成资源浪费
- 同步双方初始连接号：一来一回才能确保双方的初始序列号能被可靠的同步
- 避免历史浪费：没有第三次握手，服务端不清楚客户端是否收到了自己回复的ACK，所以服务端没收到一个SYN就只能先主动建立一个连接。如果SYN在网络中阻塞了多次发送，服务端收到请求后就会建立多个冗余的无效链接造成不必要的资源浪费
### **为什么每次建立TCP连接初始化的序列号都不一样**
- 防止历史报文被下一个相同四元组的连接接受
- 防止被伪造相同序列号的TCP被对方接收
### **为什么TCP层还需要MSS**
IP分片丢失，收不到ACK导致整个IP报文所有分片都要重传，IP层本身没有超时重传机制，通过TCP来实现。而通过协商建立的MSS，发生丢包时也是以MSS为单位重发，提高效率
### **第一次握手丢失会发生什么**
触发超时重传，重传的SYN报文序列号都是一样的，每次超时时间都是上次的两倍，五次超时重传达到上限后，仍然没有回复ACK就不再发送SYN然后断开TCP连接
### **第二次握手丢失会发生什么**
客户端认为是第一次丢失了，触发超时重传，重发SYN
服务端认为是第二次丢失了，触发超时重传，重发SYN+ACK
### **第三次握手丢失会发生什么**
客户端进入ESTABLISHED状态，发送ACK而服务端收不到，服务端认为是第二次丢包了，就重发SYN+ACK，直到重传上限或成功连接（ACK报文是不会有重传的，当ACK丢失了就由对方重传相应的报文）

### **如何避免SYN攻击**
- 调大netdev_max_backlog
- 增大TCP半连接队列
- 开启tcp_syncookies
- 减少SYN+ACK重传次数
### **TCP四次挥手**

1. 客户端打算关闭连接，此时发送一个TCP首部FIN标志位1的报文，也即FIN报文，之后客户端进入FIN_WAIT_1状态
2. 服务端收到该报文后，就向客户端发送ACK应答报文，接着服务端进入CLOSE_WAIT状态
3. 客户端收到ACK后进入FIN_WAIT_2状态
4. 服务端处理完数据后，也向客户端发送FIN报文，之后服务端进入LAST_ACK状态
5. 客户端收到FIN后，回一个ACK然后进入TIME_WAIT状态
6. 服务端收到ACK后，进入CLOSE
7. 客户端经过2MSL后，自动进入CLOSE状态
### **为什么需要四次挥手**
服务端需要等待处理数据，FIN和ACK需要分开来发送，特定情况下可以三次
### **第一次挥手丢失了会发生什么**
客户端发送FIN后进入FIN_WAIT_1状态，如果能收到服务端的ACK那么就进入FIN_WAIT_2状态，如果第一次握手丢失了，那么就触发超时重传机制，如果超时重传达到了3次，那么就断开连接
### **第二次挥手丢失会发生什么**
服务端回一个ACK然后进入CLOSE_WAIT状态。如果第二次丢失了，那么客户端收不到ACK就会认为是第一次丢失了，触发超时重传机制。
当客户端收到第二次握手时，就会进入FIN_WAIT_2状态等待第三次挥手，FIN_WAIT_2默认持续时间60s，如果60秒后还没有收到第三次挥手，连接就会关闭。如果主动关闭方只关闭了发送方向，接收方向没有关闭，意味着还可以接收数据，如果一直没收到第三次挥手，那么将会一直处于FIN_WAIT2状态
### **第三次挥手丢失了会发生什么**
服务端处于CLOSE_WAIT状态发送FIN第三次挥手之后进入LAST_ACK，等待第四次握手ACK，收不到ACK就进行超时重传，当超过三次就断开连接
客户端处于FIN_WAIT_2，timeout时间内收不到第三次挥手就会断开连接
### **第四次挥手丢失会发生什么**
客户端收到第三次挥手后回ACK报文，然后进入TIME_WAIT状态，持续2MSL再关闭
如果第四次ACK报文没有抵达，服务端会重发FIN报文
### **为什么TIME_WAIT等待的时间是2MSL**
MSL（报文最大生存时间）应当大于TTL（经过路由器跳数）消耗为0的时间，2MSL是一来一回时间，2MSL允许报文至少丢失一次
### **为什么需要TIME_WAIT状态**
- 防止历史连接中的数据，被后面相同四元组的错误连接接收：序列号和初始序列号会发生回绕为初始值的情况，无法根据序列号判断新老数据。TIME_WAIT的2MSL足够报文自然消失，再出现的新数据包一定是新数据包
- 保证被动关闭的一方正确关闭：确保等待足够时间让最后的ACK能被被动接收方接收，帮助其正确关闭
### **TIME_WAIT过多危害**
**客户端**占满了所有的端口资源，无法再对目标IP+端口相同的目标发起连接。不同的服务端可以连接，因为内核在定位连接时通过四元组定位
**服务端**TCP连接过多会占用系统资源，文件描述符、内存、cpu资源等
### **如何优化TIME_WAIT**
- 打开net.ipv4.tcp_tw_reuse & net.ipv4.tcp_timestamps
- Net.ipv4.tcp_max_buckets
- 程序中使用SO_LINGER，应用强制使用RST关闭
### **服务器出现大量TIME_WAIT原因有哪些**
- HTTP没有使用长连接：大多数Web服务都是服务端主动关闭连接（客户端/服务端一方关闭KeepAlive也都是服务端主动关闭），KeepAlive初衷是为了服务端后续请求重用连接，且服务端主动关闭连接减少一次syscall，避免调用select/epoll和read()
- HTTP长连接超时：一定时间内没有请求响应，达到超时定时，自动关闭连接出现TIME_WAIT
- HTTP长连接请求过多
### **服务端出现大量CLOSE_WAIT状态原因有什么**
服务端程序没有调用close函数
- 没有将socket注册到epoll，无法感知并获取socket
- 没有调用accept获取该连接socket，导致大量客户端主动断开连接，服务端没机会对这些连接调用close
- 没有将已连接的socket注册到epoll，后续收到FIN时无法感知这个事件
- 关闭连接后没有执行close函数
### **如果已经建立了连接，但是客户端突然出现了故障**
触发TCP保活机制，如果连接一段时间内没有任何连接相关的活动，TCP每隔一段时间发送探测报文，如果连续几个报文都没有回复则报告当前TCP已死亡
- 对端主机正常，则保活报文正常回复，保活时间被重置
- 对端主机宕机并重启，对端响应但是没有这个连接的有效信息，则回复RST报告连接已经重置
- 对端主机宕机或其他原因导致报文无法抵达，则连续几次抵达探测次数后，报告连接已死亡
### **已经建立了连接但是服务端进程奔溃会发生什么**
TCP信息由内核维护，当服务端进程奔溃后，内核主动发起挥手结束连接，回收连接资源
### **针对TCP如何socket编程**
1. 客户端和服务器初始化socket得到文件描述符
2. 服务端调用bind将socket绑定在指定ip和端口
3. 服务端调用listen监听
4. 服务端调用accept等待连接
5. 客户端调用connect向服务端发起请求
6. 服务端accept返回用于传输的socket的文件描述符
7. 客户端调用write写入，服务端调用read读取
8. 客户端调用close，当服务端read数据是读取到EOF，待处理完数据后服务端调用close
用于监听和传输数据的socket是两个socket，一个叫**监听socket**，一个叫**已完成连接socket**
### **Listen时参数backlog的意义**
Accept全连接队列
### **Accept发生在三次握手哪一步**
客户端connect成功返回是在第二次握手，accept成功返回是在三次握手之后
### **没有accept能建立TCP链接吗**
可以。Accept不参与三次握手，只负责从全连接队列中取出一个已经建立连接的socket
### **没有listen可以建立TCP连接吗**
可以。客户端一个自己连自己（TCP自连接），也可以两个客户端连接（TCP同时打开），这两个情况都有个共同点都是没有服务端参与，没有listen
# **TCP重传、滑动窗口、流量控制、拥塞控制**
### **重传机制**
- 超时重传：数据包丢失或确认应答丢失时触发；RTO应略大于报文往返RTT的时间，是动态变化的值，TCP采样RTT加权平均，采样RTT波动范围。超时重传再重传策略是超时间隔加倍
- 快速重传：数据驱动，当收到三个相同的ACK报文时，再定时器过期之前，重传丢失报文，无法解决重传一个还是重传所有的问题
- SACK方法：将已收到的数据的信息发给发送方，只重传丢失的数据
- Duplicate SACK：使用SACK告诉发送方有哪些数据被重复接受了
### **滑动窗口**
窗口大小就是无需等待确认应答，而可以继续发送数据的最大值。TCP头中Window字段，接收方告诉发送发自己还有多少缓冲区可以接收数据
SND.WND：表示发送窗口的大小
SND.UNA：绝对指针，指向已发送但未收到确认的第一个字节的序列号
SND.NXT：绝对指针，指向未发送但可发送的第一个字节的序列号
可用窗口大小 = SND.WND - (SND.NXT - SND.UNA)
### **流量控制**
让发送方根据接收方的实际接受能力发送的数据量
发送窗口和接收窗口中所存放的字节数，都是放在操作系统内存缓冲区中的，而操作系统的缓冲区，会被操作系统调整
TCP规定不允许同时减少缓存又收缩窗口，而是先收缩窗口，再减少缓存，这样就避免了丢包情况
窗口大小为0时，就会阻止发送方给接收方传递数据，直到窗口变为非0为止，这就是窗口关闭。当发生窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口非0的ACK报文，当这个报文丢失时，发送方会一直等待接收非0通知，接收方也一直等待发送方数据，导致死锁。TCP通过设置定时器，只要TCP连接一方收到对方的零窗口通知，就启动持续定时器，如果超时就发送窗口探测报文，而对方在确认这个探测报文时，会给出自己现在的接收窗口大小。
	**糊涂窗口综合症：** 接收方腾出几个字节告诉发送方，而发送方就发送这几个字节的数据。TCP+IP头部40个字节，数据几个字节，不经济。如何解决：
1、让接收方不通告小窗口：当窗口大小小于min(mss,缓存/2)就通告窗口为0，当窗口大小≥MSS或缓存有超过一半的空间再打开窗口
2、让发送方不发送小数据：Nagle算法，满足以下任一条件才可以发送数据：
	(1) 窗口大小≥MSS且数据大小≥MSS
	(2) 收到之前发送数据的ACK包
### **拥塞控制**
避免发送方数据塞满网络，拥塞窗口cwnd根据网络拥塞状况动态变化。网络中出现拥塞则cwnd变小，当发生超时重传，就认为出现了网络拥塞。
1. 慢启动：每收到一个ACK，cwnd大小加1，发送数据^2，发包个数指数增长，当cwnd<ssthresh（慢启动门限）使用慢启动，≥ssthresh时使用拥塞避免算法
2. 拥塞避免算法：每收到一个ACk，cwnd增大1/cwnd，线性增长，当再发生拥塞后，进入拥塞发生算法
3. 拥塞发生：
	(1) 超时重传：ssthresh设置为cwnd/2，cwnd重置为初始值
	(2) 快速重传：cwnd设置为cwnd/2，ssthresh设置为cwnd，进入快速恢复算法

4. 快速恢复算法：
	(1) cwnd = ssthresh+3
	(2) 重传丢失数据包
	(3) 如果收到重复ACK，cwnd重置初始值
	(4) 收到新ACK后，将cwnd设置为第一步中的ssthresh值

# **TCP全连接和半连接队列**
服务端收到SYN请求后，内核会把该链接储存到半连接队列中，完成三次握手后内核会把连接移出半连接队列，创建新的连接并加入accept全连接队列中
### **TCP全连接队列溢出**
当服务端并发处理大量请求时，如果全连接队列太小，就容易溢出。发生TCP全连接溢出时，后续的请求就会被丢弃，这样就会出现服务端请求数量上不去的现象。
可以通过设置指定当全连接队列满时，使用什么策略回应客户端，还可以回复RST告诉客户端建立连接失败。
tcp_abort_on_overflow为0时，server扔掉client发来的ack；为1时。发送一个reset给client表示废掉这个握手过程和这个连接；一般设置为0更有利于应对突发流量。服务端只丢弃ACK，客户端只要没收到为请求返回的ACK就会重复发送请求。如果服务端进程只是短暂繁忙，当全连接队列有空位时，收到的报文由于含有ACK，就会成功建立连接
### **增大TCP全连接队列**
TCP全连接队列的最大值取决于somaxconn和backlog之间的最小值
### **TCP半连接队列溢出**
半连接队列的最大长度不一定由tcp_max_syn_backlog决定
满足三个任意条件，SYN包则会被丢弃
1. 半连接队列满且没有开启tcp_syncookies
2. 全连接队列满且没有重传SYN+ACK包的连接请求多于一个
3. 没有开启tcp_syncookies且max_syn_backlog减去当前半队列长度小于(max_syn_backlog >> 2)
半连接队列最大值不单单由max_syn_backlog决定，还和somaxconn和backlog有关系
服务器处于SYN_RECV状态最大个数有两个情况
1. 半连接队列没超过理论最大值，但是超过max_syn_backlog - (max_syn_backlog >> 2)，那么处于SYN_RECV状态的最大个数就是max_syn_backlog - (max_syn_backlog >> 2)
2. 超过理论最大值，则最大个数就是理论最大值
开启syncookies功能就可以在不使用半连接队列情况下成功建立连接
### **如何防御SYN攻击**
- 增大半连接队列
- 开启tcp_syncookies功能
- 减少SYN+ACK重传次数
# **如何优化TCP**
### **TCP三次握手的性能提升**
#### **客户端优化：**
优化SYN_SENT状态。客户端等待ACK，SYN超时重传次数由tcp_syn_retires次数控制，根据网络稳定性和目标繁忙程度修改SYN报文重传次数
#### **服务端优化：**
调大半连接队列，增大tcp_max_syn_backlog、somaxconn、backlog；开启syncookies，设置为1应对SYN攻击；优化SYN_RCV，修改SYN+ACK重发次数，调整tcp_synack_retires参数；
#### **绕过三次握手：**
三次握手导致HTTP请求要在一个RTT后才能发送，使用TCP Fast Open功能减少TCP连接建立时的1RTT时延，绕过三次握手；
	TFO工作原理：客户端发送SYN报文，包含Fast Open选项，请求Cookies；服务器生成Cookies通过SYN-ACK一起返回；客户端缓存Cookies，再次建立连接发送SYN时包含Cookies和数据，服务器校验Cookies并处理数据，返回的SYN+ACK也包含数据

### **四次挥手的性能提升**
#### **主动方的优化：**
- 调用close()完全关闭连接造成孤儿连接orphans，优化FIN_WAIT_1状态，降低tcp_orphan_retires值，减少重发次数；
- 优化FIN_WAIT_2持续时间，tcp_fin_timeout
- 调整tcp_max_tw_buckets参数，当TIME_WAIT的连接数量超过该参数时，新关闭的连接就不再经历TIME_WAIT而直接关闭
- 打开tcp_tw_reuse参数，复用处于TIME_WAIT状态的连接，只作用connect函数即客户端（需要支持时间戳）
- 设置socket选项，l_onoff非0且l_linger为0，那么当调用close会立刻发送一个RST给对端，TCP跳过四次握手直接关闭
#### **被动方的优化**
出现大量CLOSE_WAIT状态下在应用程序中找问题
优化处于CLOSE_WAIT状态下的FIN报文重发次数（tcp_orphan_retires），如果被动方迅速迅速调用close，那么FIN和ACK可能在一个报文中发送，这样看起来就变成了三次挥手
- **如果双方同时主动关闭连接**，发送FIN时，都认为自己是主动方，进入了FIN_WAIT_1状态，FIN报文重发仍由tcp_orphan_retires控制，双方在等待ACK报文过程中，都等来了FIN报文，链接就进入CLOSEING状态，代替FIN_WAIT_2状态
### **TCP传输数据的性能提升**
- 扩大接收窗口大小，但网络传输能力有限，当发送端根据发送窗口发送超过网络处理能力的报文时，路由器就会直接丢弃这些报文，因此缓冲区的内存不是越大越好的
- 调整发送、接收缓冲区范围，tcp_wmem、tcp_rmem
- 打开接收缓冲区动态调节，tcp_moderate_rcvbuf。高并发服务器中，应保证缓冲区的动态调整的最大值达到带宽时延积，最小值保持4k不变；对于内存紧张的服务调低默认值是提高并发的有效手段。
- 调整内存范围，tcp_mem。对于网络IO型服务器，调大tcp_mem上限可以让TCP连接使用更多系统内存，有利于提高并发能力
# **如何理解是TCP面向字节流协议**
### **如何理解字节流**
TCP面向字节流，UDP面向报文的协议，因为操作系统对TCP和UDP的**发送方机制不同**。
用户消息使用UDP发送时，操作系统不会对消息进行拆分，每个UDP报文就是一个用户消息。操作系统收到UDP报文后，将其插入队列中，每个元素就是一个UDP报文
用户通过TCP协议传输时，消息可能会被操作系统分组为多个TCP报文，不能认为一个用户消息对应一个TCP报文，所以TCP是面向字节流的协议
### **如何解决粘包**
分包：固定长度的消息；特殊字符作为边界；自定义消息结构
# **为什么每次TCP建立连接时，初始号序列号都要不同**
防止报文被下一个相同四元组的链接接收。
如果正常挥手，报文会在2MSL中自然丢失，但是不能保证每次链接都正常关闭
客户端和服务端初始序列号不一样也会存在收到历史报文的可能，历史报文是否被接收还要看该报文的序列号是否正好在对方接收窗口内。每次建立链接客户端和服务端的初始序列号都不一样，就有大概率历史报文不在对方接收窗口，大程度避免了历史报文
TCP时间戳便于精确计算RTT，同时能防止序列号回绕，防回绕序列号算法要求双方维护时间戳并比较，当发现数据包中时间戳不是递增的话就表示该数据包过期直接丢弃
	解决时间戳回绕：
	1. 增大32bit到64bit，但是会出现新旧协议兼容问题
	2. 将一个与时钟频率无关的值作为时间戳，时钟频率可以增加但时间戳的增速不变

# **SYN报文什么情况下会被丢弃**
- NAT环境下开启了tcp_tw_recycle：客户端A、B通过同一个NAT网关发送给服务器，相同的IP建立的连接，如果客户端B的时间戳timestamp比A的小，由于服务端的pre-host的PAWS机制丢弃主机B的SYN包
- 全连接、半连接队列满
# **已经建立连接的TCP收到SYN会发生什么**
一个已经建立的TCP链接，客户端宕机了而服务端一直处于Established状态，客户端恢复后向服务端建立链接
- 客户端SYN端口号与历史连接不同：如果恢复后发的新端口号和历史端口号不同，服务端会认为是新的链接要建立，就会三次握手建立新的链接。旧的连接中，由于客户端链接已经关闭，当服务端发送数据包时客户端内核就会回RST，服务端收到后就会释放连接。如果服务端一直没发报告，就会触发保活机制kill链接
- 客户端SYN端口号历史连接相同： 处于Established服务端收到SYN（此时的SYN时乱序的，初始化序列号是个随机数），会回复一个携带了正确序列号和确认号的ACK报文，称为Challenge ACK，服务端收到这个ACK后发现确认号不是自己想要的，就会回复一个RST，服务端收到后就会释放连接
### **如何关闭一个TCP链接**
杀掉服务端/客户端进程影响范围不同。杀掉客户端发送FIN报文结束这个客户端和服务端建立的所有TCP链接，其他客户端进程不受影响；杀掉服务端则会关闭所有TCP链接，无法继续提供服务
Killcx：通过发送SYN报文收到ChallengeACK获取合法确认号，即是下次的序列号，伪造RST报文发给服务端/客户端
Tcpkill：在双方通信时候拿到对方下一个期望收到的序列号，将序列号填充到伪造的RST报文中发给对方，**不适合关闭非活跃的TCP链接**
# **四次挥手中遇到乱序FIN包如何处理**
FIN报文比数据包先抵达客户端，此时FIN报文是个乱序的报文，客户端的TCP并不会从FIN_WAIT_2转换到TIME_WAIT，会把报文加入**乱序队列**，等再次收到前面被网络延迟的数据包时，会判断乱序队列有没有数据，然后检测队列中有无可用数据，如果在乱序队列中找到与当前报文的序列号保持顺序的报文，就会查看是否有FIN标志，如果有标志才会进入FIN状态
# **TIME_WAIT状态的TCP链接收到SYN会发生什么**
首先看**SYN序列号和时间戳是否合法**
- 合法SYN：客户端SYN序列号比服务端期望序列号大，且SYN时间戳比服务端最后收到报文的时间戳大
- 非法SYN：客户端序列号比服务端期望序列号小，或SYN时间戳比服务端最后收到报文时间戳小
### **收到合法SYN**
如果处于TIME_WAIT的链接收到合法TCP后，就会重启此四元组链接，跳过2MSL进入SYN_RECV状态，重新建立连接
### **受到非法SYN**
再回复一个第四次挥手的ACK，客户端收到后发现不是自己期望收到确认号，回复RST给服务端
### **在TIME_WAIT状态收到RST会断开链接吗**
net.ipv4.tcp_rfc1337设置为0会提前结束TIME_WAIT，设置为1则会丢弃报文
# **TCP链接，一端断电和进程崩溃有什么区别**

### **无数据传输且没有开启KeepAlive**
- 主机奔溃，服务端无法感知，一直处于Established状态
- 进程奔溃，内核会发送FIN和服务端四次挥手
### **有数据传输时**
#### **客户端主机宕机且迅速重启：**
- 服务端发送的报文一直得不到回复，触发超时重传机制。服务端重传报文过程中，客户端重启后就会接收重传报文并回复
- 客户端主机**没有**进程绑定该TCP报文的目标端口号，那么客户端内核就会回复RST重置该TCP链接
- **有**进程绑定该TCP的目标端口号，由于主机重启后之前TCP的数据结构已经丢失，找不到对应的socket，就回复RST重置该链接
### **客户端主机宕机一直没有重启：**
超时重传达到一定次数后，内核判断该TCP有问题，通过Socket接口告诉应用程序该TCP连接出问题了，断开链接
TCP报文重传次数根据tcp_retires2设置，每一轮的RTO超时时长都是倍数增长
# **拔掉网线后原本的TCP连接还存在吗**
### **有数据传输**
如果**及时**将网线插回去了，客户端还是可以接收回复报文，无事发生
如果**没有及时**将网线插回去，超时重传抵达阈值后内核判断TCP出问题，断开连接；等把网线插回去后，服务端已经没有与客户端相同四元组的连接了，此时服务端就会回复RST，客户端释放连接
重传次数由tcp_retires2控制，重传间隔达到根据tcp_retires2计算出的timeout上限后就会停止重传断开连接
### **没有数据传输**
没有开启keepalive，连接会一直存在
开启了keepalive，会触发TCP保活机制
# **为什么tcp_tw_reuse默认关闭**
快速复用TIME_WAIT状态的端口，导致新链接可能被回绕序列号的RST报文断开了，而如果不跳过TIME_WAIT等待2MSL，这个RST报文就会消失而不会出现在下一个链接； 主动关闭方跳过TIME_WAIT如果四次挥手的ACK丢失了，有可能被动关闭的一方不能被正常的关闭（主动方复用连接后收到重传的第三次挥手，而处于syn_sent状态下的主动方回复一个RST断开连接）
# **HTTPS中TLS和TCP能同时握手吗**
一般情况下，不管TLS握手次数如何，都得先经过TCP三次握手才能进行
满足以下条件才能TLS和TCP同时进行三次握手
- 客户端和服务端都开启了TCP Fast Open，且TLS是1.3
- 客户端和服务器已经经过了一次通信
	TLS1.3会话恢复机制，重连TLS1.3只要0RTT
# **TCPkeepalive和HTTPKeepalive是一个东西吗**
不是，HTTP是应用层（用户态）实现的，被称为HTTP长连接；TCP是由TCP层（内核态）实现的，被称为TCP保活机制
**HTTPKeepalive**称为长连接，由应用程序实现，多次在一个TCP连接内通信，给HTTP流水线（无需等待相应多次发送请求）提供了可实现的基础；HTTP长连接有超时机制
**TCPKeepalive**是TCP的保活机制，由内核实现
# **TCP协议有什么缺陷**
### **升级TCP的工作很困难**
TCP协议在操作系统内核中实现的，应用程序只能使用不能修改，如果要升级TCP协议，那么只能升级内核。TCP有比较好的特性升级，也很难快速推广
### **TCP建立连接的延迟**
基于TCP实现的应用协议，都需要先三次握手才能进行数据传输（HTTP等），如今大部分网站都使用HTTPS，这就需要再TLS四次握手。增加了数据传输的延迟。TCP Fast Open解决了这个问题
### TCP存在队头阻塞问题
TCP层必须保证收到的字节数据是完整且有序的，如果序列号较低的TCP端在网络传输中丢失了，即使序列号较高的TCP段已经被接受了，应用层也无法从内核中读取到这部分数据
### **网络迁移需要重新建立TCP链接**
基于TCP的HTTP是通过四元组定位一条TCP连接的，当移动设备网络从4G切换到WIFI时，意味着地址变化了，就必须重新建立TCP链接
# **如何基于UDP协议实现可靠传输**
QUIC基于UDP，已经在HTTP/3应用
### QUIC是如何实现可靠传输的
UDP Header + (Packet Header + QUIC Frame Header + HTTP3 Frame Header) +HTTP Message
	**Packger Header**：首次建立连接时和日常传输的Header是不同的，LongPacketHeader（源链接ID+目标链接ID）用于首次建立链接，ShortPacketHeader（目标链接ID+编号+负载数据）用于日常传输数据。
QUIC也需要三次握手建立连接，为了协商链接ID实现连接迁移功能；ShortPacketHeader中的Packet Number时独一无二，且递增的，PacketN丢失了，重传的报文PacketNumber也是大于N的，这样设计的目的是**更精准的计算RTT**，没有TCP重传的歧义性问题；同时单调递增可以让数据包支持**乱序确认**，当数据包N丢失时，只要有新的数据包接受确认，当前窗口就会继续向右滑动
**QUIC Frame Header:** 一个报文中可以存放多个QUIC Frame，每个Frame都有明确的类型，类型不同，功能、格式也不同。
Stream的Frame格式，Stream可以认为是一条HTTP请求：
	StreamID作用：多个并发的HTTP请求通过不同的StreamID加以区分，类似HTTP2的Stream
	Offset作用：类似TCP的Seq序号，保证数据顺序性和可靠性
	Length作用：指明了Frame数据长度
QUIC通过单项递增的PacketNumber配合StreamID与Offset字段（N丢失了，重传数据包N+2的StreamID和Offset都和N一样，说明两个数据包内容一致），可以支持乱序确认而不影响数据包的正确组装
### **QUIC如何解决TCP队头阻塞**
QUIC给每个Stream分配了一个独立的滑动窗口，这样使得一个链接上的多个Stream没有依赖关系，都是相互独立的，各自控制的滑动窗口
### **QUIC如何流量控制**
通过window_update帧告诉对端自己可以接收的字节数，通过BlockFrame告诉对端由于流量控制被阻塞了，无法发送数据。
QUIC的每个Stream有各自的滑动窗口，不同Stream相互独立，队头的Stream被阻塞后不妨碍StreamB、C的阻塞。
QUIC实现了两种级别的流量控制:
	Stream级别：每个Stream可以看作一个HTTP请求，每个Stream都可以做流量控制，防止单个Stream消耗连接的全部接收缓冲；
	Connection流量控制：限制连接中所有的Stream相加起来的总字节数，防止发送方发送超过连接的缓冲容量
### **QUIC对拥塞控制的改进**
QUIC默认使用了TCP的Cubic控制算法，同时也支持CubicBytes、Reno等算法，QUIC可以随浏览器更新，拥塞控制就可以较快更迭，针对不同的应用设置不同的算法
### **QUIC更快的连接建立**
HTTP/3的QUIC内部包含了TLS，在自己的帧会携带TLS的记录，再加上QUIC使用的是TLS1.3，只需一个RTT就能同时完成建立连接和密钥协商，第二次建立连接时应用数据包和QUIC握手信息同时发送，达到0RTT效果
### **QUIC是如何迁移连接的**
使用链接ID标记通信两个端点，无缝复用原链接
# **TCP和UDP可以使用同一个端口吗**
### **TCP和UDP可以同时绑定相同的端口吗**
**监听**只有TCP中有，UDP中没有，两者都会调用bind绑定端口。
	TCP的UDP可以同时绑定相同的端口。端口是为了区分同一个主机上不同应用程序的数据包，TCP和UDP在内核中是两个完全独立的软件模块，主机收到数据包后，可以在IP包头的协议号字段知道该数据包是TCP/UDP，再根据端口号发给应用程序，TCP/UDP的端口号也相互独立，TCP/UDP可以有相同的端口号
### **多个TCP进程可以绑定同一个端口吗**
如果多个TCP进程绑定的**IP+端口都相同**，则执行bind()的时候就会出错
### **重启TCP进程时，为什么会有Address in use的报错信息**
此时相当于主动关闭方进入了TIME_WAIT状态，在2MSL时间里连接的IP+PORT仍然是有效组合，相同机器不能绑定同样的IP+PORT，bind()时就会返回 address in use。
在重启TCP bind()调用之前对socket设置SO_REUSEADDR属性可以解决；
	**SO_REUSEADDR作用是**：如果当前启动进程绑定的IP+PORT和处于TIME_WAIT状态的链接占用的IP+PORT相同，但新启动的进程使用了该选项，那么该进程就可以绑定成功
### **客户端的端口可以重复使用吗**
TCP是通过四元组定位的，客户端可以使用相同端口和不同IP服务端链接，不会造成连接冲突
### **客户端TCP TIME_WAIT状态过多，会导致端口资源耗尽而无法建立新的连接吗**
要看客户端是否都是和同一个服务端（目标地址、端口相同）建立链接，只要客户端连接的服务端不是同一个，那么端口是可以重复使用的
### **如何解决客户端TCP TIME_WAIT状态过多，导致无法与同一个服务器建立连接的问题**
打开net.ipv4.tcp_tw_reuse
# **服务端没有listen，客户端发起连接会发生什么**
如果服务端只bind了IP+PORT没有调用listen，客户端对服务器发起链接，服务器会回复RST
### **没有listen能建立链接吗**
可以，TCP自连接和TCP同时打开，都没有半连接队列。
	TCP自连接情况中，客户端在connect时，会将自己链接的信息放入全局hash表中，然后将表发出，消息在经过回环地址重新回到TCP传输层时，会根据IP+PORT再从全局hash中去除信息，握手包一来一回成功建立连接
# **没有accept能建立TCP链接吗**
不执行accept，三次握手照样进行，顺利建立链接。服务端执行accept前，如果客户端发消息给服务端，服务端是能正常回复ack确认包的
# **用了TCP协议，数据就一定不会丢吗**
### **数据包的发送流程**
数据包从**聊天软件**所在的**用户空间**拷贝到**内核空间的发送缓冲区**，顺着传输层、网络层进入到**数据链路层，**经过**流控qdisc再通过RingBuffer发送到物理层网卡，**经过路由器和交换机抵达**目的机器的网卡**
此时目的机器网卡会通知**DMA**将数据放到RingBuffer中，再触发一个**硬中断给CPU**，CPU触发**软中断让ksoftirqd去RingBuffers**收包，再顺着物理层、链路层、网络层、传输层发送到软件里
### **建立连接时丢包**
第二次握手后半连接队列暂存半连接，第三次握手将半连接升级为全连接存入全连接队列等待程序accept取用。**队列满了就会丢包**
### **流量控制丢包**
qdisc流量控制机制，控制数据排队，数据发送过快，流控队列长度又不够大就容易出现丢包
通过ifconfig查看TX下的dropped字段，大于0时则可能流控丢包。修改txqueuelen修改流控队列长度
### **网卡丢包**
RingBuffer接收缓冲区过小导致丢包，修改RingBuffer长度减少因为容量小导致丢包的；网卡性能不足，传输速度达到上限
### **接收缓冲区丢包**
通过net.ipv4.tcp_wmen/rmem查看接收/发送缓冲区大小，当接收缓冲区满了，TCP接收窗口就会变成0，所谓的零窗口，这种情况下再收到发来的数据就会丢包
### **两端之间网络丢包**
Ping查看丢包，只能知道机器和目的机器之间有无丢包
Mtr可以查看机器和目的机器之间每个节点的丢包情况
### **用了TCP就一定不会丢包了吗**
TCP只能保证传输层可靠性，不能保证机器其他层数据的完整性，其他层可能因为各种原因导致丢包
### **这种丢包怎么解决**
应用层自己实现逻辑保证完整性，比如引入第三方服务器
# **TCP四次挥手可以变成三次吗**
### **为什么是四次挥手**
第三次挥手的控制权不在内核，而是在被动关闭方的应用程序，取决于被动关闭方是否有数据需要发送，再调用关闭链接的函数。
不管进程是否正常退出还是异常退出，内核都会发送FIN报文完成四次挥手
### **粗暴关闭vs优雅关闭**
- close函数，关闭socket发送和接受方向，如果多进程/线程共享一个socket，close只是让socket引用计数-1，不会导致socket不可用，也不会发出FIN报文，直到引用计数变为0，才会发出FIN
- shutdown可以指定关闭socket发送方向而不关闭接收方向，如果多线程进程共享一个socket，shutdown直接让该socket不可用并发出FIN
close关闭socket导致不再具有发送和接收能力，客户端内核会直接回RST给服务端，释放连接，这时就不会再经历四次挥手，调用close是粗暴关闭
Shutdown可以读取到数据，然后经历完整四次挥手，所以是优雅关闭
### **什么情况会出现三次挥手**
被动关闭方**没有数据要发送且开启了TCP延迟确认机制**，第二次和第三次挥手就会合并传输
TCP延迟确认：
- 有响应数据要发送时，ACK和相应数据会一起发送给对方
- 没有响应要发送时，ACK会延迟以等待是否有响应数据可以一起发送
- 如果在等待延迟发送ACK期间，对方的第二个数据报文又抵达了，就会立刻发送ACK
通过Socket中TCP_QUICKACK设置关闭TCP延迟确认机制
# **TCP序列号和确认号是如何变化的**
序列号解决乱序问题，确认号解决丢包问题
- 公式一：序列号 = 上一次发送的序列号+len（数据长度）。如果上次发送的是SYN或者FIN，则改为上次发送的序列号+1
- 公式二：确认号 = 上次收到报文中的序列号+len（数据长度）。收到SYN或者FIN改为上次收到报文序列号+1
# **IP基本认识**
IP在TCP/IP模型中处于第三层，也就是网络层，实现主机与主机之间的通信，也叫点对点通信。而**MAC层**作用是实现**直连**的两个设备之间通信，而**IP层**负责在**没有直连**的两个设备之间通信
计算机网络中需要**数据链路层**和**网络层**这个分层才能实现最终目标地址的通信。在网络数据包传输中，**源IP和目标IP是不会变化的（没有开启NAT网络），只有源MAC和目标MAC在一直变化**
# **IP地址的基础知识**
IPv4地址由32位构成，采用了分店十进制标记，最大有43亿个地址，使用NAT技术可以让可连接计算机数量超过43亿
### **IP地址分类**
对于A、B、C类主要分为两个部分，分别是网络号和主机号
	- A类 0.0.0.0~127.255.255.255 最大主机数16777214
	- B类 128.0.0.0~191.255.255.255 最大主机数65534
	- C类 192.0.0.0~223.255.255.255 最大主机数254

最大主机个数 = 2^主机号位数 - 2
减去的2是两个特殊的主机号，主机号全为1指定某个网络下的所有主机用于广播；主机号为0指定某个网络
### **广播地址用于什么**
广播地址用于在同一个链路中相互连接的主机之间发送数据包。将地址的主机部分全部改为1，则形成广播地址
广播地址可以分为本地广播和直接广播两种：
	在本网络内广播的叫做本地广播；在不同网络之间的叫直接广播
### **什么是D、E类地址**
D、E类地址是没有主机号的，所以不可用于主机IP，D类多被用于多播，E类是预留的分类，暂未使用
### **多播地址用于什么**
多播用于将包发送给特定组内的所有主机
### IP分类的优缺点
**优点**简单明了、选路简单
**缺点**同一网络下没有地址层次，缺少地址的灵活性；ABC类不能很好的与现实网络匹配。可以通过无分类地址CIDR解决
### **无分类地址CIDR**
32位的IP被分为两部分，前面是网络号，后面是主机号
a.b.c.d/x前面被称为网络号，x的范围是0~32
还有通过子网掩码划分主机号和网络号，将子网掩码和IP按位计算AND得到网络号
### **为什么要分离网络号和主机号**
两个计算机通信，首先判断是否处于同一个广播域中，即网络地址是否相同，再把数据包直接发到接收方主机
### **怎么进行子网划分**
子网掩码进行划分子网，将主机地址划为子网网络地址和子网主机地址
做子网划分后的IP地址：网络地址+（子网网络地址+子网主机地址）
### **环回地址**
127.0.0.1是同一台计算机上程序之间用来网络通信的默认地址
### **IP分片与重组**
每种数据链路的最大传输单元MTU都是不同的，FDDI的MTU4352，以太网MTU1500。当IP数据包大小大于MTU时，IP数据包就会被分片，分片数据只会由目标主机重组，一旦某个分片丢失，整个IP数据作废；所以TCP引入了MSS也就是在TCP层分片不由IP层分片，对于UDP尽量不要发送大于MTU的数据

### **IPv6基本认识**
IPv6地址是128位的
IPv6可自动配置，没有DHCP也可以实现自动分配地址，便捷到即插即用；IPv6包头包长度采用固定的40字节，去掉了包头校验和，简化了首部结构，提高了传输性能；IPv6由应对伪造地址和防窃听的功能，提高了安全性
### **IPv6地址标识方法**
16进制标识，每16位位一组，用冒号隔开
### **IPv6地址主要类型**
- 单播地址，用于一对一
- 组播地址，用于一对多
- 任播地址，用于通信最近的节点，由路由协议决定
- 没有广播地址
### **IPv6单播地址类型**
- 在同一链路单播地址，不经过路由器，可以使用**链路本地单播地址**，IPv4没有此类型
- 内网内单播，可以使用**唯一本地地址**，相当于IPv4的私有IP
- 互联网内通信，可以使用**全局单播地址**，相当于IPv4的公有IP
### **IPv4首部和IPv6首部**
IPv6首部改进
- **取消了首部校验和字段。**因为在数据链路层和传输层都会校验，直接取消了IP校验
- **取消了分片/重新组装相关字段**。IPv6只能在源和目标主机进行操作，提高路由器转发速度
- **取消选项字段**。可能出现在[下一个首部]指出的位置上，删除该字段使IPv6首部成为固定长度的40字节
### **DHCP****动态获取IP地址**
DHCP客户端监听68端口，服务端监听67端口
1. 客户端首先发起**DHCP发现报文**的IP数据报，客户端没有IP地址也不知道DHCP服务器的地址，使用UDP广播通信，目的地址255.255.255.255:67，使用0.0.0.0:68作为源IP
2. DHCP服务端收到DHCP发现报文后，用**DHCP提供报文**响应，报文地址任是255.255.255.255，携带服务端提供可租约的IP地址、子网掩码、默认网关、DNS以及IP地址租用期
3. 客户端收到DHCP提供报文后，选择一个服务器，向选中的服务器发送**DHCP请求报文**进行响应
4. 最后服务端用**DHCP ACK报文**对DHCP请求报文进行响应
DHCP中继代理可以对不同网段的IP地址分配也由一个DHCP服务器统一进行管理
# **PING的工作原理**
### **ICMP**
互联网控制报文协议，确认IP包是否成功送达目标地址、报告发送过程中IP包被丢弃的原因和改善网络设置等
ICMP包头类型字段主要分为两大类，**查询报文类型**和**差错报文类型**
#### **查询报文类型**
**回送消息**用于进行通信的主机或路由器之间，判断所发送的数据包是否成功到达对端的一种消息，ping就是利用这个消息实现的
#### **差错报文类型**
IP路由器无法将IP数据包发给目标地址是，会给发送端主机返回一个**目标不可达**的ICMP啥消息，并显示不可达的具体原因
### **PING**
执行ping命令时，原主机首先会构建一个ICMP回送消息数据包，包含**类型（回送消息为8）和序号（区分多个数据包）**，然后ICMP将数据包连同地址一起交给IP层，由IP层构建数据包，加入MAC头等发送给目标。主机B收到后构建一个ICMP回送响应消息给A
	Ping使用了ICMP中的ECHO REQUEST和ECHO REPLY
### **traceroute差错报文类型的使用**
1. 设置特殊的TTL，来追踪去目的地时途径的路由器。通过设置TTL发送的带所有路由器IP；traceroute发送UDP时会加入一个不可能的端口号作为探针，目的主机收到后会返回**端口不可达**，**所以当差错报文类型是端口不可达时，说明发送的UDP抵达了目标主机**
2. 故意不设置不分片，确定路径的MTU
# **断网了还能Ping通127.0.0.1吗**
### **什么是127.0.0.1**
127开头的IP都属于回环地址
### **TCP发数据和Ping的区别**
- TCP发数据是创建socket使用SOCK_STREAM**工作在传输层**，在socket中调用sendto从用户态进入内核态，最后调用sock_sendmsg，进入传输层加上TCP头IP头MAC头进入网卡ringbuffer发送
- Ping发数据创建socket时用的SOCK_RAW，**工作在网络层**，其他和TCP相同（没有TCP头是ICMP头）
### **为什么断网了还能ping127.0.0.1**
系统会根据ping的地址选择网卡发消息，如果是**外网IP则会通过帧网卡**，**回环地址则会使用本地网卡**
	本地网卡没有Ringbuffer，而是会把数据推到input_pkt_queue链表中，这个链表所有网卡共享，挂着发给本机的所有数据，消息被发给这个链表后会再触发一个软中断，内核线程再去把消息取出，发给应用程序
Ping回环地址和TCP各种协议发数据给回环地址都是这个途径
### **Ping回环地址和ping本机地址有什么区别**
lo0标识本机回环接口，对应地址就是回环地址
eth0标识本机第一块网卡，对应本机IP
ping本机IP和ping回环地址都是走lo0假网卡，**没有区别**
### **127.0.0.1和localhost和0.0.0.0有区别吗**
Localhost是域名，默认解析为127.0.0.1
Ping0.0.0.0会失败，因为在IPv4中代表无效地址；启动服务器时listen0.0.0.0，代表本机所有IPv4地址，但是客户端connect时不能使用0.0.0.0