# 锁（未完成）
### 悲观锁
先上锁，再处理数据，保证了并发的安全性，但是降低了效率
例如mysql的排它锁，select xxx for update强制锁住
mysql中行级锁基于索引的，如果sql没有走索引，那将用表级锁把整个表锁住
### 乐观锁
#### CAS
包含了三个操作数
1. 需要读写的内存位置V
2. 进行比较的预期值A
3. 拟写入的新值B
如果内存位置V的值等于预期的A值，则将该位置更新为新值B，否则不进行任何操作。许多CAS的操作是自旋的：如果操作不成功，会一直重试，直到操作成功为止。
	这里引出一个新的问题，既然CAS包含了Compare和Swap两个操作，它又如何保证原子性呢？
	答案是：CAS是由CPU支持的原子操作，其原子性是在硬件层面进行保证的。
#### 版本号
版本号机制的基本思路是在数据中增加一个字段version，表示该数据的版本号，每当数据被修改，版本号加1。
- 当某个线程查询数据时，将该数据的版本号一起查出来；
- 当该线程更新数据时，判断当前版本号与之前读取的版本号是否一致，如果一致才进行操作。
需要注意的是，这里使用了版本号作为判断数据变化的标记，实际上可以根据实际情况选用其他能够标记数据版本的字段，如时间戳等。
### redis锁

# 红黑树
### 什么是红黑树
#### 二叉查找树BST
1. **左**子树上所有结点的值均**小于或等于**它的根结点的值
2. **右**子树上所有结点的值均**大于或等于**它的根结点的值
3. 左、右子树也分别为二叉排序树
利用二分查找思想，查找所需最大次数等于二叉树高度，插入节点也是一层层比较找到新节点适合插入位置
二叉查找数存在可能成为瘸子的**缺点**![[Pasted image 20231225214257.png]]
#### 红黑树
1. 节点是红色或黑色
2. 根节点是黑色
3. 每个叶子节点都是黑色的空节点（NIL节点）
4. 每个红色节点的两个子节点都是黑色(从每个叶子到根的所有路径上不能有两个连续的红色节点)
5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点
红黑树保证了从根到叶子的最长路径不会超过最短路径的两倍，插入或旋转红黑树的时候，需要**变色、左旋转、右旋转**来解决
### 红黑树的相关操作
#### 变色
为了重新符合红黑树的规则，尝试把红色节点变为黑色，或者把黑色节点变为红色
#### 左旋转
**逆时针**旋转红黑树的两个节点，使得父节点被自己的右孩子取代，而自己成为自己的左孩子
#### 右旋转
**顺时针**旋转红黑树的两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子
#### 插入操作
RBTree的插入与BST的插入方式是一致的，只不过是在插入过后，可能会导致树的不平衡，这时就需要对树进行旋转操作和颜色修复（在这里简称插入修复），使得它符合RBTree的定义
新插入的节点是红色的，插入修复操作如果遇到父节点的颜色为黑则修复操作结束。也就是说，只有在父节点为红色节点的时候是需要插入修复操作的
插入修复操作分为以下的三种情况，而且新插入的节点的父节点都是红色的：
1. 叔叔节点也为红色
2. 叔叔节点为空，且祖父节点、父节点和新节点处于一条斜线上
3. 叔叔节点为空，且祖父节点、父节点和新节点不处于一条斜线上
插入后的修复操作是一个向root节点回溯的操作，一旦牵涉的节点都符合了红黑树的定义，修复操作结束。之所以会向上回溯是由于case 1操作会将父节点，叔叔节点和祖父节点进行换颜色，有可能会导致祖父节点不平衡(红黑树定义3)。这个时候需要对祖父节点为起点进行调节（向上回溯）
祖父节点调节后如果还是遇到它的祖父颜色问题，操作就会继续向上回溯，直到root节点为止，根据定义root节点永远是黑色的。在向上的追溯的过程中，针对插入的3中情况进行调节。直到符合红黑树的定义为止。直到牵涉的节点都符合了红黑树的定义，修复操作结束
如果上面的3中情况如果对应的操作是在右子树上，做对应的镜像操作就是了
#### 删除操作
删除操作首先需要做的也是BST的删除操作，删除操作会删除对应的节点，如果是叶子节点就直接删除，如果是非叶子节点，会用对应的中序遍历的后继节点来顶替要删除节点的位置。删除后就需要做删除修复操作，使的树符合红黑树的定义，符合定义的红黑树高度是平衡的
删除修复操作在遇到被删除的节点是红色节点或者到达root节点时，修复操作完毕
删除修复操作是针对删除黑色节点才有的，当黑色节点被删除后会让整个树不符合RBTree的定义的第四条。需要做的处理是从兄弟节点上借调黑色的节点过来，如果兄弟节点没有黑节点可以借调的话，就只能往上追溯，将每一级的黑节点数减去一个，使得整棵树符合红黑树的定义
删除操作的总体思想是从兄弟节点借调黑色节点使树保持局部的平衡，如果局部的平衡达到了，就看整体的树是否是平衡的，如果不平衡就接着向上追溯调整。
删除修复操作分为四种情况(删除黑节点后)：
1. 待删除的节点的兄弟节点是红色的节点
2. 待删除的节点的兄弟节点是黑色的节点，且兄弟节点的子节点都是黑色的
3. 待调整的节点的兄弟节点是黑色的节点，且兄弟节点的左子节点是红色的，右节点是黑色的(兄弟节点在右边)，如果兄弟节点在左边的话，就是兄弟节点的右子节点是红色的，左节点是黑色的
4. 待调整的节点的兄弟节点是黑色的节点，且右子节点是是红色的(兄弟节点在右边)，如果兄弟节点在左边，则就是对应的就是左节点是红色的
#### 参考文献
[漫画：什么是红黑树](https://juejin.cn/post/6844903519632228365#comment)
[红黑树深入剖析及Java实现](https://zhuanlan.zhihu.com/p/24367771)
