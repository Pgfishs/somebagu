# 操作系统中进程通信方式
管道：单向传输数据，是内核中的缓存，通信效率低
消息队列：内核中的消息链表，不适合大数据传输，存在内核态/用户态拷贝开销
共享内存：虚拟空间映射到相同的物理地址上，但是会被覆盖
信号量：P、V操作（复杂）
信号：
Socket
（后三个没想起来）
# 互斥锁和读写锁（GPT）
在 Go 中，互斥锁（Mutex）和读写锁（RWMutex）都是用于保护共享资源的并发访问的同步机制，它们的主要区别如下：
功能：互斥锁用于对临界区代码进行互斥访问，即同一时间只能有一个 goroutine 进入临界区，其他 goroutine 需要等待。读写锁允许多个 goroutine 并发读取共享资源，但只允许一个 goroutine 写入共享资源，且在写入时不允许有其他 goroutine 进行读取或写入。
锁定方式：互斥锁在使用时需要调用 Lock() 方法进行锁定，然后在临界区执行完毕后调用 Unlock() 方法进行解锁。而读写锁提供了两种锁定方式，分别是读锁和写锁。通过调用 RLock() 方法获取读锁，多个 goroutine 可以同时持有读锁，实现并发读取。通过调用 Lock() 方法获取写锁，只允许一个 goroutine 持有写锁，实现独占写入。
性能：由于读写锁允许并发读取，适用于读多写少的场景，可以提高并发性能。而互斥锁在读写操作之间都需要加锁和解锁，会导致并发性能下降。
锁的持有者：互斥锁只有一个持有者，即在某一时刻只有一个 goroutine 可以持有互斥锁。而读写锁可以被多个 goroutine 同时持有读锁，但只能被一个 goroutine 持有写锁。
锁的公平性：互斥锁是非公平锁，即在解锁时不保证等待的 goroutine 的获取顺序。读写锁也是非公平锁，但是在写锁等待时会优先满足写锁请求，以避免写饥饿问题。