# 执行select期间发生了什么
### 第一步：连接器
通过连接器链接Mysql，Mysql都是通过TCP协议进行传输的。当空连接超过`wait_timeout`参数时将会自动断开；Mysql默认最大连接数是151个，和HTTP一样都有长短连接概念，可以通过**定期断开长连接**和**客户端主动重置链接**来解决长连接占用内存的问题
### 第二步：查询缓存
服务端解析SQL语句，先去查询缓存中是否有这个语句（以k-v缓存），被命中则直接返回value，*在8.0以后Mysql将查询缓存删除了*
### 第三步：解析SQL 解析器
#### 第一步：词法分析
根据输入字符串识别关键词，得到TOKEN
#### 第二步：语法分析
根据词法分析结果，语法解析器根据语法规则判断语法，构建SQL语法树，方便后续模块获取SQL类型、表名等
### 第四步：执行SQL
每条SELECT经过三个阶段
- prepare预处理
- optimize优化阶段
- execute执行阶段
#### 预处理器
- 检查SQL语句中表或字段是否存在
- 将`select *`中`*`扩展为表上所有列
#### 优化器
负责将SQL查询语句执行方案确定下来，比如多个引索时确定引索，确定覆盖引索/普通引索等
#### 执行器
- 主键索引查询
- 全表扫描
- 索引下推
**主键索引下推**
- 执行器第一次查询，调用read_first_record指针，这个指针被指向InnoDB索引查询的接口，吧id = 1交给储存引擎，让储存引擎定位符合条件的第一个记录
- 返回记录，不存在则报错
- 执行器判断记录是否符合查询条件，返回记录或跳过该记录
- 执行器查询是while循环，再查一次调用read_record指向的函数，被定位为永远返回-1的函数，退出循环
**全表扫描**
- 第一次查询调用read_first_record，指向InnoDB全扫描接口，让存储引擎读取表中的第一条记录
- 执行器判断条件是否符合，发给客户或跳过
- 执行器while循环查询，存储引擎调用read_record根据条件查询完全表，直到读完整个表，返回读取完毕
- 执行器收到读取完毕，退出
**索引下推**
能减少二级索引在查询时的回表操作，提高查询效率，因为他将Server层事情交给存储引擎去处理了
不适用索引下推时，存储引擎根据二级索引B+树定位到记录后获取主键值，进行徽标操作返回给Server层判断联合索引的条件；使用索引下推时，不回表，先判断索引中的条件是否成立，不成立直接跳过，成立再执行回表操作
# Mysql一行记录的储存
### Mysql数据的存放
/var/lib/mysql/dbname目录下，db.opt储存当前数据库默认字符集和校验规则；xxx.frm储存表结构，保存每个表的元数据信息；xxx.ibd保存表数据，每个表默认存放一个独立的.ibd文件
#### 表空间文件的结构
表结构由**段（segment）、区（extent）、页（page）、行（row）** 组成
##### 行
表中结构都是按行存放，每行记录根据不同的行格式有不同的存储结构
##### 页
InnoDB按**页**为单位读取数据，每个页默认大小为16KB
页的类型有很多，常见有数据页、undo日志页、溢出页等。数据表中行记录是用数据页来管理的
##### 区
表中数据量大时，按照区为单位为索引分配空间。每个区大小为1MB，64个16KB的连续的页会被划为一个区，使相邻页中物理位置也相同，就能顺序I/O
##### 段
一般分为数据段、索引段、回滚段
- 索引段：存放B+树非叶子节点的区的集合
- 数据段：存放B+树叶子节点的区的集合
- 回滚段：存放回滚数据的区的集合
### InnoDB行格式
提供四种行格式
- Redundant，5.0以前用的行格式
- Compact，紧凑行格式存放更多行记录，5.1后默认行格式
- Dynamic&Compressed紧凑行格式，和Compact差不多，从5.7后默认使用Dynamic
### Compact行格式长什么样
#### 记录的额外信息
##### 变长字段长度列表
varchar和char区别->变长字段实际存储的数据长度时不固定的，把数据占用的大小存进**变长字段长度列表**中，读取数据时根据这个去读对应长度的数据。变长字段真实占用的字节数会按照列的顺序**逆序存放**（使靠前记录的真实数据和队友长度信息同时在一个cacheline中提高命中率）；NULL不会存在真实数据中，当数据表没有变长字段时，就没有这个列表了
##### NULL值列表
每个列对应一个二进制位，位为1时代表为NULL（逆序存放），同理无NULL时就没列表
##### 记录头信息
- delete_mask：标识数据是否被删除
- next_record：下一条记录位置
- record_type：当前记录类型，0普通记录，1B+树非叶子节点记录，2最小记录，3最大记录
#### 记录的真实数据
定义的字段+三个隐藏字段
- row_id：InnoDB会添加这个隐藏字段，当指定了主键或唯一约束列，就没有这个字段了，占用6个字节
- trx_id：事务id，表示由哪个事务生成；必需的，6个字符
- roll_pointer：这个记录上个版本的指针；必需的，7个字符
### varchar最大取值
Mysql中规定除TEXT、BLOBs其他所有列占用字节长度加起来不超过65535字节
#### 单字段情况
一行数据的最大字节数是65535，其中包含了storage overhead，即**变长字段长度列表**&**NULL值列表**占用字节数，在算varchar(n)的n最大值时需要减去上面占的字节数；实际上varchar被分为三个部分来储存
- 真实数据
- 真实数据占用的字节数
- NULL标识
UTF-8下，最大n取值时21844（一个字符需要三个字节）
#### 多字段情况
保证所有字段长度+变长字段字节数列表占用字节数+NULL值列表占用字节数<=65535
### 行溢出后Mysql是怎么处理的
一个页一般是16KB，当存大对象时一个页可能存不了一个记录，就会发生**行溢出**，多的数据就会存到另外的溢出页中，在记录的真实数据处只会保存该列一部分数据，用20字节指向存储溢出页的地址；Dynamic和Compressed使用完全的行溢出方式，真实地址处只储存20个字节指针指向溢出页
