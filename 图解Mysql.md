# 执行select期间发生了什么
### 第一步：连接器
通过连接器链接Mysql，Mysql都是通过TCP协议进行传输的。当空连接超过`wait_timeout`参数时将会自动断开；Mysql默认最大连接数是151个，和HTTP一样都有长短连接概念，可以通过**定期断开长连接**和**客户端主动重置链接**来解决长连接占用内存的问题
### 第二步：查询缓存
服务端解析SQL语句，先去查询缓存中是否有这个语句（以k-v缓存），被命中则直接返回value，*在8.0以后Mysql将查询缓存删除了*
### 第三步：解析SQL 解析器
#### 第一步：词法分析
根据输入字符串识别关键词，得到TOKEN
#### 第二步：语法分析
根据词法分析结果，语法解析器根据语法规则判断语法，构建SQL语法树，方便后续模块获取SQL类型、表名等
### 第四步：执行SQL
每条SELECT经过三个阶段
- prepare预处理
- optimize优化阶段
- execute执行阶段
#### 预处理器
- 检查SQL语句中表或字段是否存在
- 将`select *`中`*`扩展为表上所有列
#### 优化器
负责将SQL查询语句执行方案确定下来，比如多个引索时确定引索，确定覆盖引索/普通引索等
#### 执行器
- 主键索引查询
- 全表扫描
- 索引下推
**主键索引下推**
- 执行器第一次查询，调用read_first_record指针，这个指针被指向InnoDB索引查询的接口，吧id = 1交给储存引擎，让储存引擎定位符合条件的第一个记录
- 返回记录，不存在则报错
- 执行器判断记录是否符合查询条件，返回记录或跳过该记录
- 执行器查询是while循环，再查一次调用read_record指向的函数，被定位为永远返回-1的函数，退出循环
**全表扫描**
- 第一次查询调用read_first_record，指向InnoDB全扫描接口，让存储引擎读取表中的第一条记录
- 执行器判断条件是否符合，发给客户或跳过
- 执行器while循环查询，存储引擎调用read_record根据条件查询完全表，直到读完整个表，返回读取完毕
- 执行器收到读取完毕，退出
**索引下推**
能减少二级索引在查询时的回表操作，提高查询效率，因为他将Server层事情交给存储引擎去处理了
不适用索引下推时，存储引擎根据二级索引B+树定位到记录后获取主键值，进行徽标操作返回给Server层判断联合索引的条件；使用索引下推时，不回表，先判断索引中的条件是否成立，不成立直接跳过，成立再执行回表操作
# Mysql一行记录的储存
### Mysql数据的存放
/var/lib/mysql/dbname目录下，db.opt储存当前数据库默认字符集和校验规则；xxx.frm储存表结构，保存每个表的元数据信息；xxx.ibd保存表数据，每个表默认存放一个独立的.ibd文件
#### 表空间文件的结构
表结构由**段（segment）、区（extent）、页（page）、行（row）** 组成
##### 行
表中结构都是按行存放，每行记录根据不同的行格式有不同的存储结构
##### 页
InnoDB按**页**为单位读取数据，每个页默认大小为16KB
页的类型有很多，常见有数据页、undo日志页、溢出页等。数据表中行记录是用数据页来管理的
##### 区
表中数据量大时，按照区为单位为索引分配空间。每个区大小为1MB，64个16KB的连续的页会被划为一个区，使相邻页中物理位置也相同，就能顺序I/O
##### 段
一般分为数据段、索引段、回滚段
- 索引段：存放B+树非叶子节点的区的集合
- 数据段：存放B+树叶子节点的区的集合
- 回滚段：存放回滚数据的区的集合
### InnoDB行格式
提供四种行格式
- Redundant，5.0以前用的行格式
- Compact，紧凑行格式存放更多行记录，5.1后默认行格式
- Dynamic&Compressed紧凑行格式，和Compact差不多，从5.7后默认使用Dynamic
### Compact行格式长什么样
#### 记录的额外信息
##### 变长字段长度列表
varchar和char区别->变长字段实际存储的数据长度时不固定的，把数据占用的大小存进**变长字段长度列表**中，读取数据时根据这个去读对应长度的数据。变长字段真实占用的字节数会按照列的顺序**逆序存放**（使靠前记录的真实数据和队友长度信息同时在一个cacheline中提高命中率）；NULL不会存在真实数据中，当数据表没有变长字段时，就没有这个列表了
##### NULL值列表
每个列对应一个二进制位，位为1时代表为NULL（逆序存放），同理无NULL时就没列表
##### 记录头信息
- delete_mask：标识数据是否被删除
- next_record：下一条记录位置
- record_type：当前记录类型，0普通记录，1B+树非叶子节点记录，2最小记录，3最大记录
#### 记录的真实数据
定义的字段+三个隐藏字段
- row_id：InnoDB会添加这个隐藏字段，当指定了主键或唯一约束列，就没有这个字段了，占用6个字节
- trx_id：事务id，表示由哪个事务生成；必需的，6个字符
- roll_pointer：这个记录上个版本的指针；必需的，7个字符
### varchar最大取值
Mysql中规定除TEXT、BLOBs其他所有列占用字节长度加起来不超过65535字节
#### 单字段情况
一行数据的最大字节数是65535，其中包含了storage overhead，即**变长字段长度列表**&**NULL值列表**占用字节数，在算varchar(n)的n最大值时需要减去上面占的字节数；实际上varchar被分为三个部分来储存
- 真实数据
- 真实数据占用的字节数
- NULL标识
UTF-8下，最大n取值时21844（一个字符需要三个字节）
#### 多字段情况
保证所有字段长度+变长字段字节数列表占用字节数+NULL值列表占用字节数<=65535
### 行溢出后Mysql是怎么处理的
一个页一般是16KB，当存大对象时一个页可能存不了一个记录，就会发生**行溢出**，多的数据就会存到另外的溢出页中，在记录的真实数据处只会保存该列一部分数据，用20字节指向存储溢出页的地址；Dynamic和Compressed使用完全的行溢出方式，真实地址处只储存20个字节指针指向溢出页
# 索引
数据的目录，Mysql存储引擎有MyISA、InnoDB、Memory，InnoDB在5.5后称为默认存储引擎
### 索引分类
- 数据结构分类：B+树索引、Hash索引、Full-text索引
- 物理存储分类：聚簇索引（主键索引）、二级索引（辅助索引）
- 字段特性分类：主键索引、唯一索引、普通索引、前缀索引
- 字段个数分类：单列索引、联合索引

|  类型  |InnoDB|MyISAM|Memory|
| ----- |------|------|------|
|B+|Y|Y|Y|
|HASH|N|N|Y|
|FullText|Y|Y|N|
InnoDB在5.5后成为默认存储引擎，会根据不同场景使用不同列做索引
- 有主键默认使用主键作为聚簇索引的key
- 没有主键则使用第一个不包含NULL的唯一列作key
- 都没有则生成隐式自增id作为key
创建的主键索引和二级索引默认使用B+索引
B+树是多叉树，叶子节点存放数据，非叶子节点存放所有，每个节点的数据都是按主键顺序存放的，每一层夫索引值都出现在下层子节点的索引值中，所以叶子节点中包括所有的索引值信息，每个叶子节点之间都有双向链表。B+树查找千万级数据只要3~4次IO
#### 唯一索引 
一张表可以有多个唯一索引，索引列的值必须唯一，允许空值
#### 前缀索引
对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段为char类的列上
#### 联合索引 
存在最左匹配原则，按照最左优先方式进行索引匹配，不遵循则联合索引会失效
联合索引存在特殊情况，在范围查询的字段可以用到联合索引，在范围查询字段后的字段无法用到联合索引
#### 索引下推 
在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数
#### 索引区分度
建立联合索引时，要把区分度大的字段排在前面，区分度大的字段越有可能被更多sql使用到
### 什么时候需要创建索引
索引也存在缺点
- 占用物理空间，数量越大占用空间越大
- 创建索引和维护索引需要耗费时间
- 降低表的增删改效率，每次增删改索引，B+树都需要动态维护
##### 什么时候适用索引
- 字段有唯一性限制的
- 常用WHERE查询条件的
- 常用GROUP BY和ORDER BY的
##### 什么时候不需要创建索引
- WHERE、GROUP BY、ORDER BY用不到的字段
- 字段中存在大量重复数据
- 表数据太少
- 经常维护的字段
### 索引优化办法
#### 前缀索引优化
减少索引字段大小，增加一个索引页中存储的索引值，提高查询效率，减小索引项大小；但也存在局限性
- order by无法使用前缀索引
- 无法把前缀索引用作覆盖索引
#### 覆盖索引优化
指SQL中query的所有字段，在索引B+树叶子节点上都能找到的索引，从二级索引中查询到的记录，而不需要通过聚簇索引查询获得，避免回表
#### 主键索引最好自增
InnoDB创建主键索引默认为聚簇索引，存在B+树叶子节点上，按主键顺序存放的。使用自增主键，每次插入叶子节点都是追加操作，不需要移动数据；而使用非自增主键，可能会移动数据造成页分裂，产生内存碎片
主键字段越小，二级索引叶子节点越小，占用空间越小
#### 索引最好设置为NOTNULL
- 存在NULL使优化器选择索引时复杂，难以优化
- 无意义但是会占用物理空间
#### 防止索引失效
- 左、右模糊匹配时，都会造成索引失效
- 查询时对索引列作了计算、函数、类型转换会造成失效
- 联合索引没能匹配最左匹配原则会造成失效
- WHERE语句中OR前条件列是索引列，而OR后条件列不是索引列，会造成索引失效
尽量让SQL使用range以上级别type访问方式，type字段扫描效率
- 全表扫描
- 全索引扫描
- 索引范围扫描
- 非唯一索引扫描
- 唯一索引扫描
- 结果只有一条的主键或索引扫描
# 数据页看B+树
### InnoDB储存数据
按**数据页**为单位读写，默认大小是16KB，即一次IO最少16KB
*InnoDB格式：*

|名称|说明|
|---|---|
|文件头(38字节)|表示页信息|
|页头(56字节)|表示页状态信息|
|最大、最小记录(26字节)|虚拟伪记录，表示页中最大最小记录|
|用户记录(不确定)|储存行记录内容|
|空闲空间(不确定)|页中未被使用空间|
|页目录(不确定)|储存用户记录相对位置，起索引作用|
|文件尾(8字节)|校验页是否完整|
文件头中有两个指针，指向上/下一个人页，连起来形成双向链表，构成逻辑上的联系
数据页中的记录按照**主键**顺序组成单向链表，数据页中有**页目录**，起到记录索引作用
页目录创建过程：
- 将记录分为多个组，包括最大最小记录，但不包括“已删除”记录
- 将每个记录组最后一条记录（组内最大记录），且最后一条记录头信息会存有该组共多少条记录，作为n_owned字段
- 页目录存储每组最后一条记录地址偏移量，这些偏移量会按照先后顺序存储，且这些地址也被称之为**槽**，每个槽相当于指针指向了不同组的最后一个记录
页目录就是由多个槽组成的，槽相当于分组记录的索引。槽是按照主键值大小从小到大排序，通过槽查找记录时，使用二分法定位需要查询的槽，定位到槽后遍历所有记录，找到对应记录
InnoDB对分组中记录有规定
- 第一个分组中记录只有一个记录
- 最后一个分组中记录条数在1-8条之间
- 剩下分组记录条数范围再4-8条之间
### B+树如何查询
InnoDB使用B+树作为索引，每个节点都是一个数据页
- 只有叶子节点存放数据，其他节点仅存放目录项作索引
- 非叶子节点分不同层次，通过分层降低每一层搜索量
- 所有节点按照索引键大小快速排序，构成双向链表
### 聚簇索引和二级索引
- 聚簇索引叶子节点存放实际数据，所有完整用户数据都存放在聚簇索引叶子节点
- 二级索引叶子节点存放主键值，而非实际数据
InnoDB一定会为表创建一个聚簇索引，有且仅有一个，会根据不同场景选择不同列作为索引
- 主键
- 无主键则选择第一个不包含NULL的唯一列
- 都没有则自动生成隐式自增id
如果某个查询语句用了二级索引，但查询的数据不是主键值，那么找到二级索引后需要去聚簇索引中获得数据行，这个过程就叫回标，就是需要查两个B+树才能得到数据。查询的是主键时，通过二级索引就能查到，不再用聚簇索引，这时候叫索引覆盖
# 为什么使用B+树作索引
### 二分查找树
一个节点左子树所有节点都小于这个节点，右子树都大于这个节点
当每次插入元素都是最大元素时，就会退化成链表
树的高度就是查询时磁盘IO次数
### 自平衡二叉树
AVL树，左右子树高度不超过1，还有红黑树通过约束达到自平衡
不管是AVL树还是红黑树，都会随着插入元素变多导致树高度增加，磁盘IO次数多，影响查询效率（二叉树限制）
### B树
B树每个节点最多可以包含M个子节点，称为B树的阶，多叉树可以降低树的高度。每个节点最多有M-1个数据和M个子节点，超过要求则会分裂节点
B树每个节点都包含索引+记录，记录数据的大小可能远超索引大小，就需要更多磁盘IO读到有用数据；如果读最底层节点时，回加载不要的数据，占用内存数据，且范围查找时需要中序遍历，设置到磁盘IO问题
### B+树
- 叶子节点存放数据，非叶子节点存放索引
- 所有所有都会在叶子节点出现，叶子节点间构成有序链表
- 非叶子节点的所有也会同时存在子节点中，且是子节点中所有索引最大（最小）
- 非叶子节点中有多少子节点，就有多少索引
#### 单点查询
B树最快O(1)就能查到数据，但查询波动大
数据量相同时，B+树非叶子节点可以存放更多索引，因此B+树比B树更矮胖，查询底层节点磁盘IO次数更少
#### 插入和删除效率
B树没有冗余节点，删除时可能发生复杂的树的变形，插入也同理，B+树只涉及树的一条路径；且B+树会自动平衡，不需要更多复杂算法，比如红黑树的旋转
#### 范围查询
B+树所有叶子节点之间用链表链接，而B树只能通过遍历完成范围查找
#### Mysql中B+树
见上一篇
# Mysql单表最大值
单表数据达到2000w时，查询时长急剧上升
### 单表数量限制
主键大小可以限制表的上限
- 主键int声明，最大支持2^32~21亿
- bigint则是2^62-1
建表时自增字段选择无符号bigint，则自增最大值是18446744074709551615

### 单表建议值
索引B+树的非叶子节点存放索引，叶子节点存放数据，一个16K的页非叶子节点每个每条数据都指向新的页，新的页有两种可能
- 叶子节点则是数据
- 非叶子节点则继续指向新页
设非叶子节点指向其他页数量为x，叶子节点内数据行数为y，B+树层数为z，则**Total = x^(z-1) * y，总数等于x的z-1次方与y乘积**
#### X=?
索引和页一样存在页结构，+页目录大小为1k，整个数据页剩余15K存放数据，主键假设为bigint(8byte)，页号也固定(4byte)，索引中每个数据为12byte，则x=15 * 1024/12 = 1280行
#### Y=?
叶子节点和非叶子节点相同，都可以存放15k数据，假设一行数据为1k，一页最多存下15条，则Y=15 * 1024/1000 = 15
#### Total
根据公式Total = x ^ (z-1) * y，假设B+树是**2层(z=2)** 则total = 19200，**z=3**则total=2450w 即最大行数建议值2kw

在保持相同层级的情况下，行数据大小不同会导致最大建议值也不同，其他因素也会影响查询性能
Mysql为了提高性能，会将表索引加载进内存，InnoDB buffer size足够情况下能完全加载进内存，当单表数据库达到上线时，会导致内存无法储存其索引，使之后的SQL产生磁盘IO导致性能下降
# 索引失效有哪些
Schwarzschild effect 

|Name |Data1 |Data2 |Data3 |Data4 |
|---|---|---|---|---|
|Exposure (seconds) |1/1000–1/2| 1 |10 |100|
|Lengthening of exposure| 1x |2x |8x |16x |
|Correction of aperture number |0 |-1 |-3| -4|
