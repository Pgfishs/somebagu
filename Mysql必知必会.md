# 创建表
**-- 创建数据库**
`CREATE DATABASE demo；`
**-- 删除数据库**
`DROP DATABASE demo；
**-- 查看数据库**
`SHOW DATABASES;
**-- 创建数据表：**
`CREATE TABLE demo.test(barcode text,goodsname text,price int)`
**-- 查看表结构**
`DESCRIBE demo.test;
**-- 查看所有表**
`SHOW TABLES;`
**-- 添加主键**
`ALTER TABLE demo.test
`ADD COLUMN itemnumber int PRIMARY KEY AUTO_INCREMENT;
**-- 向表中添加数据**
`INSERT INTO demo.test
`(barcode,goodsname,price)
`VALUES ('0001','本',3);
# Mysql数据类型
在定义数据类型时，如果确定是整数，就用 INT；如果是小数，一定用定点数类型 DECIMAL；如果是字符串，只要不是主键，就用 TEXT；如果是日期与时间，就用 DATETIME
# Mysql增删查改
增
`INSERT INTO 表名 SELECT 字段 FROM 表名 WHERE 条件`
删
`DELETE FROM 表名 FROM`
改
`UPDATE 表名 SET 字段名=值 WHERE 条件`
查
`SELECT *|字段名 FROM 数据源 WHERE 条件
`GROUP BY 字段 HAVING 条件 ORDER BY字段 LIMIT 起始点、行数`
**GROUP BY**查询结果分组；**HAVING**查询搜索结果，和WHERE类似；**ORDER BY**查询结果如何排序，**ASC升序、DESC降序**；**LIMIT**显示部分查询结果
# Mysql如何正确设置主键
### 业务字段设置主键
容易因为需求而重复
### 自增字段设置主键
相同格式，内容不同的表之间容易出现冲突（会员卡和不同门店会员）
### 手动赋值主键
保证全局唯一性
# 外键和关联查询
### 如何创建外键
``` SQL
CREATE TABLE 从表名 （ 字段名 类型...）
CONSTRAINT 外键约束名 FOREIGN KEY（字段名）
REFERENCE 主表名（字段名）
```

也可以修改表
``` SQL
ALTER TABLE 从表名 ADD CONSTRAINT 约束名 FOREIGN KEY 字段名 REFERENCE 主表名（字段)
```

### 链接
#### 内连接
查询结果只返回符合链接条件的记录，JOIN、INNER JOIN、CROSS JOIN含义都是一样的，JOIN和ON配对使用，返回满足关联条件的所有内容
#### 外连接
还可以返回表中所有的记录，包括**左连接**和**右连接**
**左连接LEFT JOIN**，返回左边表中的所有记录和右表中符合连接条件的记录
右连接相反
### 关联查询误区
外键查询不是关联查询必要条件，有了外键约束，Mysql才会保证系统数据，避免出现误删
# where和having有什么区别
### where
WHERE 关键字的特点是，直接用表的字段对数据集进行筛选。如果需要通过关联查询从其他的表获取需要的信息，那么执行的时候，也是先通过 WHERE 条件进行筛选，用筛选后的比较小的数据集进行连接。这样一来，连接过程中占用的资源比较少，执行效率也比较高。
### having
having需要和group by组合使用
group by对数据按要求进行分组
### 如何正确使用where和having
- 如果需要通过连接从关联表中获取需要的数据，WHERE是先筛选后连接，而HAVING 是先连接后筛选。
- WHERE 可以直接使用表中的字段作为筛选条件，但不能使用分组中的计算函数作为筛选条件；HAVING 必须要与 GROUP BY 配合使用，可以把分组计算的函数和分组字段作为筛选条件
where先筛选数据再关联，执行效率高，不能使用分组中的计算函数进行筛选
havinf可以使用分组中的计算函数，但是在最后的结果集中筛选，执行效率低
# 聚合函数
### SUM
返回指定字段值的和；Left(str,n)返回str左边n个字符
求和函数获取的是分组中的合计数据，要知道按照什么字段进行分类的
### AVG、MAX、MIN
AVG返回平均值，通过计算分组内指定字段值的和以及分组内的记录数，算出指定字段的平均值
MAX表示获取指定字段在分组中的最大值，MIN表示获取指定字段在分组中的最小值。
### COUNT
了解数据集的大小，计算出符合条件的记录一共有多少，可以用于解决数据量过大的问题（进行分页）
# 时间类数据
![[Pasted image 20231217225931.png]]第一种方法是，可以利用 Windows 系统自带的网络同步的方式，来校准系统时间。
另一种办法就是，门店统一从总部 MySQL 服务器获取时间。由于总部的服务器的配置和运维状况一般要好于门店，所以系统时间出现误差的可能性也较小。如果采用云服务器，系统时间的可靠性会更高。
# 数学函数
![[Pasted image 20231219231556.png]]
# 索引相关
数据表字段越多，数据记录越多，索引速度提升越明显
### 单字段索引
1. 通过 CREATE 语句直接给已经存在的表创建索引
2. 可以在创建表的同时创建索引
3. 可以通过修改表来创建索引
#### 单字段索引原理
有了索引之后，MySQL 在执行 SQL 语句的时候多了一种优化的手段。也就是说，在查询的时候，可以先通过查询索引快速定位，然后再找到对应的数据进行读取，这样就大大提高了查询的速度。
### 组合索引
数据表中字段多，层级复杂，就可以使用组合索引
如果有多个索引，而这些索引的字段同时作为筛选字段出现在查询中的时候，MySQL会选择使用最优的索引来执行查询操作
#### 组合索引原理
组合索引的多个字段是有序的，遵循左对齐的原则。筛选的条件也要遵循从左向右的原则，如果中断，那么，断点后面的条件就没有办法利用索引了；如果筛选的是一个范围，如果没有办法无法精确定位，也相当于中断；如果只用组合索引的一部分，效果没有单字段索引那么好
# 事务
### 什么是事务
事务是 MySQL 的一项功能，它可以使一组数据操作（也叫 DML 操作，是英文 DataManipulation Language 的缩写，包括 SELECT、INSERT、UPDATE 和 DELETE），要么全部执行，要么全部不执行，不会因为某种异常情况（比如硬件故障、停电、网络中断等）出现只执行一部分操作的情况
```SQL
START TRANSACTION 或者 BEGIN （开始事务）
一组DML语句
COMMIT（提交事务）
ROLLBACK（事务回滚）
```

### 事务的主要特征
**原子性**：表示事务中的操作要么全部执行，要么全部不执行，像一个整体，不能从中间打断
**一致性**：表示数据的完整性不会因为事务的执行而受到破坏
**隔离性**：表示多个事务同时执行的时候，不互相干扰。不同的隔离级别，相互独立的程度不同
**持久性**：表示事务对数据的修改是永久有效的，不会因为系统故障而失效
### 如何确保操作的原子性和数据的一致性
通过把 2 个相关操作放到事务里面，我们就实现了一个事务操作。事务并不会自动帮你处理 SQL 语句执行中的错误，如果对事务中的某一步数据操作发生的错误不做处理，继续提交的话，仍然会导致数据不一致
另一个经常会用到事务的地方是存储过程。由于存储过程中包含很多相互关联的数据操作，所以会大量使用事务。我们可以在 MySQL 的存储过程中，通过获取 SQL 错误，来决定事务是提交还是回滚
要把重要的关联操作放在事务中，确保操作的原子性，并且对失败的操作进行回滚处理
### 如何用好事务的隔离性
通过对锁的使用，可以实现事务之间的相互隔离。锁的使用方式不同，隔离的程度也不同
**MySQL 支持 4 种事务隔离等级：**
1. **READ UNCOMMITTED**：可以读取事务中还未提交的被更改的数据
2. **READ COMMITTED**：只能读取事务中已经提交的被更改的数据
3. **REPEATABLE READ**：表示一个事务中，对一个数据读取的值，永远跟第一次读取的值一致，不受其他事务中数据操作的影响。这也是 MySQL 的默认选项
4. **SERIALIZABLE**：表示任何一个事务，一旦对某一个数据进行了任何操作，那么，一直到这个事务结束，MySQL 都会把这个数据锁住，禁止其他事务对这个数据进行任何操作
对于一些核心的数据更改操作，可能需要较高的隔离等级，比如涉及金额的修改；另一方面，要考虑资源的消耗，不能使系统整体的效率受到太大的影响
### MISC
MVCC & 锁详见《MySQL实战45讲》书籍《MySQL是怎样运行的》
# 临时表
内部临时表用于性能优化，由系统自动产生，无法看到
外部临时表通过SQL语句创建
```MySQL
CREATE TEMPORARY TABLE 表名
(
字段名 字段类型,
...
);
```
### 临时表的三个特征
1. 临时表的创建语法需要用到关键字 TEMPORARY
2. 临时表创建完成之后，只有当前连接可见，其他连接是看不到的，具有连接隔离性
3. 临时表在当前连接结束之后，会被自动删除
### 用临时表简化复杂查询
通过临时表，可以把一个复杂的问题拆分成很多个前后关联的步骤，把中间的运行结果存储起来，用于之后的查询
### 磁盘临时表和内存临时表
内存临时表可以通过指定引擎类型（比如ENGINE=MEMORY），来告诉 MySQL 临时表存储在内存中
在磁盘上创建临时表时，只要不指定存储引擎，MySQL 会默认存储引擎是InnoDB，并且把表存放在磁盘上
对于同一条查询内存中的临时表查询速度更快。不过，内存中的临时表也有缺陷。因为数据完全在内存中，所以，一旦断电，数据就消失了，无法找回。不过临时表只保存中间结果，所以还是可以用的
# 视图
创建视图
```MySQL
CREATE [OR REPLACE]
VIEW 视图名称 [(字段列表)]
AS 查询语句
```
### 视图优缺点

- 可以把视图看成一张表来进行查询，所以在使用视图的时候，不用考虑视图本身是如何获取数据的，里面有什么逻辑，包括了多少个表，有哪些关联操作，可以直接使用。实际上就把查询模块化了，查询变得更加简单，提高了开发和维护的效率。可以把经常会用到的查询和复杂查询的子查询定义成视图，存储到数据库中
- 视图跟实际数据表不一样，它存储的是查询语句。在使用的时候，通过定义视图的查询语句来获取结果集。而视图本身不存储数据，不占用数据存储的资源
- 视图具有隔离性。视图相当于在用户和实际的数据表之间加了一层虚拟表。用户不需要查询数据表，可以直接通过视图获取数据表中的信息。这样既提高了数据表的安全性，同时也通过视图把用户实际需要的信息汇总在了一起，查询起来很轻松
- 视图的数据结构相对独立，即便实际数据表的结构发生变化，也可以通过修改定义视图的查询语句，让查询结果集里的字段保持不变。这样一来，针对视图的查询就不受实际数据表结构变化的影响了。
- **缺点是**如果实际数据表的结构变更了，就需要及时对相关的视图进行相应的维护。特别是当视图是由视图生成的时候，维护会变得比较复杂。因为创建视图的 SQL 查询可能会对字段重命名，也可能包含复杂的逻辑，这些都会增加维护的成本